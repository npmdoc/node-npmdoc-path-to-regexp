<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/pillarjs/path-to-regexp#readme"

    >path-to-regexp (v1.7.0)</a>
</h1>
<h4>Express style path to RegExp utility</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.path-to-regexp">module path-to-regexp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.path-to-regexp.compile">
            function <span class="apidocSignatureSpan">path-to-regexp.</span>compile
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.path-to-regexp.parse">
            function <span class="apidocSignatureSpan">path-to-regexp.</span>parse
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.path-to-regexp.tokensToFunction">
            function <span class="apidocSignatureSpan">path-to-regexp.</span>tokensToFunction
            <span class="apidocSignatureSpan">(tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.path-to-regexp.tokensToRegExp">
            function <span class="apidocSignatureSpan">path-to-regexp.</span>tokensToRegExp
            <span class="apidocSignatureSpan">(tokens, keys, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.path-to-regexp" id="apidoc.module.path-to-regexp">module path-to-regexp</a></h1>


    <h2>
        <a href="#apidoc.element.path-to-regexp.compile" id="apidoc.element.path-to-regexp.compile">
        function <span class="apidocSignatureSpan">path-to-regexp.</span>compile
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compile(str, options) {
  return tokensToFunction(parse(str, options))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Usage

```javascript
var pathToRegexp = require(&#x27;path-to-regexp&#x27;)

// pathToRegexp(path, keys, options)
// pathToRegexp.parse(path)
// pathToRegexp.<span class="apidocCodeKeywordSpan">compile</span>(path)
```

- **path** An Express-style string, an array of strings, or a regular expression.
- **keys** An array to be populated with the keys found in the path.
- **options**
- **sensitive** When `true` the route will be case sensitive. (default: `false`)
- **strict** When `false` the trailing slash is optional. (default: `false`)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.path-to-regexp.parse" id="apidoc.element.path-to-regexp.parse">
        function <span class="apidocSignatureSpan">path-to-regexp.</span>parse
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = &#x27;&#x27;
  var defaultDelimiter = options &#x26;&#x26; options.delimiter || &#x27;/&#x27;
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = &#x27;&#x27;
    }

    var partial = prefix != null &#x26;&#x26; next != null &#x26;&#x26; next !== prefix
    var repeat = modifier === &#x27;+&#x27; || modifier === &#x27;*&#x27;
    var optional = modifier === &#x27;?&#x27; || modifier === &#x27;*&#x27;
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || &#x27;&#x27;,
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? &#x27;.*&#x27; : &#x27;[^&#x27; + escapeString(delimiter) + &#x27;]+?&#x27;)
    })
  }

  // Match any characters still remaining.
  if (index &#x3c; str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Usage

```javascript
var pathToRegexp = require(&#x27;path-to-regexp&#x27;)

// pathToRegexp(path, keys, options)
// pathToRegexp.<span class="apidocCodeKeywordSpan">parse</span>(path)
// pathToRegexp.compile(path)
```

- **path** An Express-style string, an array of strings, or a regular expression.
- **keys** An array to be populated with the keys found in the path.
- **options**
- **sensitive** When `true` the route will be case sensitive. (default: `false`)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.path-to-regexp.tokensToFunction" id="apidoc.element.path-to-regexp.tokensToFunction">
        function <span class="apidocSignatureSpan">path-to-regexp.</span>tokensToFunction
        <span class="apidocSignatureSpan">(tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i &#x3c; tokens.length; i++) {
    if (typeof tokens[i] === &#x27;object&#x27;) {
      matches[i] = new RegExp(&#x27;^(?:&#x27; + tokens[i].pattern + &#x27;)$&#x27;)
    }
  }

  return function (obj, opts) {
    var path = &#x27;&#x27;
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i &#x3c; tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === &#x27;string&#x27;) {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError(&#x27;Expected &#x22;&#x27; + token.name + &#x27;&#x22; to be defined&#x27;)
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError(&#x27;Expected &#x22;&#x27; + token.name + &#x27;&#x22; to not repeat, but received `&#x27; + JSON.stringify(value) + &#x27;`&#x27;)
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError(&#x27;Expected &#x22;&#x27; + token.name + &#x27;&#x22; to not be empty&#x27;)
          }
        }

        for (var j = 0; j &#x3c; value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError(&#x27;Expected all &#x22;&#x27; + token.name + &#x27;&#x22; to match &#x22;&#x27; + token.pattern + &#x27;&#x22;, but received `&#x27; + JSON.stringify
(segment) + &#x27;`&#x27;)
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError(&#x27;Expected &#x22;&#x27; + token.name + &#x27;&#x22; to match &#x22;&#x27; + token.pattern + &#x27;&#x22;, but received &#x22;&#x27; + segment + &#x27;&#x22;&#x27;)
      }

      path += token.prefix + segment
    }

    return path
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**Note:** The generated function will throw on invalid input. It will do all necessary checks to ensure the generated path is valid
. This method only works with strings.

### Working with Tokens

Path-To-RegExp exposes the two functions used internally that accept an array of tokens.

* `pathToRegexp.tokensToRegExp(tokens, options)` Transform an array of tokens into a matching regular expression.
* `pathToRegexp.<span class="apidocCodeKeywordSpan">tokensToFunction</span>(tokens)` Transform an array of tokens into a path generator
 function.

#### Token Information

* `name` The name of the token (`string` for named or `number` for index)
* `prefix` The prefix character for the segment (`/` or `.`)
* `delimiter` The delimiter for the segment (same as prefix or `/`)
* `optional` Indicates the token is optional (`boolean`)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.path-to-regexp.tokensToRegExp" id="apidoc.element.path-to-regexp.tokensToRegExp">
        function <span class="apidocSignatureSpan">path-to-regexp.</span>tokensToRegExp
        <span class="apidocSignatureSpan">(tokens, keys, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = &#x27;&#x27;

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i &#x3c; tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === &#x27;string&#x27;) {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = &#x27;(?:&#x27; + token.pattern + &#x27;)&#x27;

      keys.push(token)

      if (token.repeat) {
        capture += &#x27;(?:&#x27; + prefix + capture + &#x27;)*&#x27;
      }

      if (token.optional) {
        if (!token.partial) {
          capture = &#x27;(?:&#x27; + prefix + &#x27;(&#x27; + capture + &#x27;))?&#x27;
        } else {
          capture = prefix + &#x27;(&#x27; + capture + &#x27;)?&#x27;
        }
      } else {
        capture = prefix + &#x27;(&#x27; + capture + &#x27;)&#x27;
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || &#x27;/&#x27;)
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where &#x22;/test/&#x22; shouldn&#x27;t match &#x22;/test//route&#x22;.
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + &#x27;(?:&#x27; + delimiter + &#x27;(?=$))?&#x27;
  }

  if (end) {
    route += &#x27;$&#x27;
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict &#x26;&#x26; endsWithDelimiter ? &#x27;&#x27; : &#x27;(?=&#x27; + delimiter + &#x27;|$)&#x27;
  }

  return attachKeys(new RegExp(&#x27;^&#x27; + route, flags(options)), keys)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

**Note:** The generated function will throw on invalid input. It will do all necessary checks to ensure the generated path is valid
. This method only works with strings.

### Working with Tokens

Path-To-RegExp exposes the two functions used internally that accept an array of tokens.

* `pathToRegexp.<span class="apidocCodeKeywordSpan">tokensToRegExp</span>(tokens, options)` Transform an array of tokens into a
matching regular expression.
* `pathToRegexp.tokensToFunction(tokens)` Transform an array of tokens into a path generator function.

#### Token Information

* `name` The name of the token (`string` for named or `number` for index)
* `prefix` The prefix character for the segment (`/` or `.`)
* `delimiter` The delimiter for the segment (same as prefix or `/`)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
